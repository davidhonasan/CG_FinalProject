<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CG Final Project</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script type="application/vertexShader" id="vertexShaderCode">
        #ifdef GL_ES
            precision highp float;
        #endif
    
        // Attributes
        attribute vec3 position;
        attribute vec2 uv;
    
        // Uniforms
        uniform mat4 worldViewProjection;
    
        // Normal
        varying vec2 vUV;
    
        void main(void) {
        gl_Position = worldViewProjection * vec4(position, 1.0);
    
        vUV = uv;
        }
    </script>
    <script type="application/fragmentShader" id="fragmentShaderCode">
        #ifdef GL_ES
            precision mediump float;
        #endif
    
        varying vec2 vUV;
    
        uniform sampler2D textureSampler;
    
        void main(void) {
            gl_FragColor = texture2D(textureSampler, vUV);
        }
    </script>
    <style>
    html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
    }
    #render {
        width: 100%;
        height: 100%;
        touch-action: none;
    }
    </style>
</head>
<body>
    <canvas id="render" touch-action="none">
    <script>
        var canvas = document.getElementById("render");
        var engine = new BABYLON.Engine(canvas, true);
        var scene = new BABYLON.Scene(engine);

        // Shader
        var shaderMaterial = new BABYLON.ShaderMaterial("shader", scene, {
            vertexElement: "vertexShaderCode",
            fragmentElement: "fragmentShaderCode",
            },
            {
            attributes: ["position", "normal", "uv"],
            uniforms: ["world", "worldView", "worldViewProjection", "view", "projection"]
        });

        // Make the sky
        var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:10000.0}, scene);
        var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        skyboxMaterial.backFaceCulling = false;
        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox/skybox", scene);
        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
        skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        skybox.material = skyboxMaterial;
                
        var mainTexture = new BABYLON.Texture("sample.jpg", scene);
        shaderMaterial.setTexture("textureSampler", mainTexture);

        // Camera
        var camera = new BABYLON.UniversalCamera("HumanCamera", new BABYLON.Vector3(0, 53, 0), scene);
        camera.rotation.y = Math.PI;
        camera.radius = 30;
        camera.attachControl(canvas);
        camera.ellipsoid = new BABYLON.Vector3(10, 7, 10);

        // Remap keys to move with WASD
        camera.keysUp = [87]; // W
        camera.keysDown = [83]; // S
        camera.keysLeft = [65]; // A
        camera.keysRight = [68]; // D

        // Collision
        scene.collisionsEnabled = true;
        scene.gravity = new BABYLON.Vector3(0, -0.9, 0);
        camera.checkCollisions = true;
        camera.applyGravity = true;

        // Light
        var sunlight = new BABYLON.HemisphericLight("Sun", new BABYLON.Vector3(0, 100, 0), scene);
        var light = new BABYLON.SpotLight("Flashlight", new BABYLON.Vector3(0, 5, -5), new BABYLON.Vector3(0, -0.15, 1), 10, 7, scene);
        light.range = 175;
        light.parent = camera;
        sunlight.intensity = 0.15;

        // Assets
        var assets = {};
        var assetsManager = new BABYLON.AssetsManager(scene);
        var city = assetsManager.addMeshTask("City", "", "city/", "city.obj");
        var axe = assetsManager.addMeshTask("Axe", "", "fireaxe/OBJ/", "FireAxe.obj");
        var ghost = assetsManager.addMeshTask("Ghost", "", "ghost/", "nintendoghost.glb")
        
        // City
        city.onSuccess = function (task) {
            for (var i = 0; i < task.loadedMeshes.length; i++){
                task.loadedMeshes[i].position = BABYLON.Vector3.Zero();
                task.loadedMeshes[i].checkCollisions = true;
            }
        }

        // Axe
        axe.onSuccess = function (task) {
            for (var i = 0; i < task.loadedMeshes.length; i++){
                task.loadedMeshes[i].parent = camera;
                task.loadedMeshes[i].position = new BABYLON.Vector3(-0.5, -9.5, 15);
                task.loadedMeshes[i].rotation = new BABYLON.Vector3(-3.28, 0, -2.61);
                task.loadedMeshes[i].scaling = new BABYLON.Vector3(0.4, 0.4, 0.4); 
                task.loadedMeshes[i].checkCollisions = true;
            }
        }

        ghost.onSuccess = function (task) {
            for (var i = 0; i < task.loadedMeshes.length; i++){
                task.loadedMeshes[i].position = new BABYLON.Vector3(0,40,100);
                task.loadedMeshes[i].scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);
                task.loadedMeshes[i].checkCollisions = true;
            }
        }

        // action manager
        scene.actionManager = new BABYLON.ActionManager(scene);

        // Pointer LOCK
        //We start without being locked.
        var isLocked = false;
            
        // On click event, request pointer lock
        scene.onPointerDown = function (evt) {
            //true/false check if we're locked, faster than checking pointerlock on each single click.
            if (!isLocked) {
                canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock || false;
                if (canvas.requestPointerLock) {
                    canvas.requestPointerLock();
                }
            }
            // LEFT CLICK
            if (isLocked && evt.buttons === 1) {
                console.log('hit');
                
                scene.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        {
                            trigger: BABYLON.ActionManager.OnPickTrigger, 
                            parameter: { 
                                mesh: ghost
                            }
                        }, 
                        function () {
                            console.log('asd');
                            ghost.loadedMeshes[0].dispose();
                        }
                    )
                );
                console.log('asd');
            }
        };

        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function () {
            var controlEnabled = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement || false;
            
            // If the user is already locked
            if (!controlEnabled) {
                camera.detachControl(canvas);
                isLocked = false;
            } else {
                camera.attachControl(canvas);
                isLocked = true;
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);
        // END OF POINTER LOCK

        // UI
        // var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("myUI");

        assetsManager.onFinish = function(tasks) {
            engine.runRenderLoop(function() {
                scene.render();
            });
        };
        assetsManager.load();
        
        scene.debugLayer.show();

        window.addEventListener("resize", function() {
            engine.resize();
        });
    </script>
    </canvas>
</body>
</html>
  
  